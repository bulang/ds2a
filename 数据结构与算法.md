## 数据结构与算法

### 栈结构

**特点：受限的线性结构，先进后出；**

#### 使用`javascript`封装栈结构

1. 使用数组或者链表实现，也可以使用对象实现；

2. 接口说明

   | 接口            | 说明                   |
   | --------------- | ---------------------- |
   | `push(element)` | 数据入栈               |
   | `pop()`         | 数据出栈并删除         |
   | `peek()`        | 查询栈顶元素不删除数据 |
   | `isEmpty()`     | 判断栈是否为空         |
   | `size()`        | 获取栈的大小           |
   | `clear()`       | 清空栈内数据           |

3. 封装

   ```javascript
   class Stack{
       constructor(){
           this.items = [];
       }
       push(element){
           this.items.push(element);
       }
       pop(){
           return this.items.pop();
       }
       peek(){
           return this.items[this.items.length-1];
       }
       size(){
           return this.items.length;
       }
       isEmpty(){
           return this.items.length === 0;
       }
       clear(){
           this.items = [];
       }
   }
   
   export default Stack;
   ```

### 队列

#### 使用`javascript`封装队列

**特点：受限的线性数据结构，先进先出**

1. 接口说明：

   | 接口               | 说明         |
   | ------------------ | ------------ |
   | `enqueue(element)` | 数据进入队列 |
   | `dequeue()` | 删除并获取队列首位数据 |
   | `clearQueue()` | 清空队列 |
   | `size()` | 获取队列长度 |
   | `front()` | 获取队列首位数据不删除 |
   | `isEmpty()` | 判断队列是否为空 |

2. 封装

   ```javascript
   class Queue{
       constructor(){
           this.items = [];
       }
       enqueue(element){
           this.items.push(element);
       }
       dequeue(){
           return this.items.shift();
       }
       clearQueue(){
           this.items = [];
       }
       size(){
           return this.items.length;
       }
       front(){
           return this.items[0];
       }
       isEmpty(){
           return this.items.length === 0;
       }
   }
   
   export default Queue;
   ```

### 优先级队列

优先级队列比队列多一个参数用来排序数据的优先级，其他特点跟队列是一样的

#### 使用`javascript`封装优先级队列

```javascript
/**
* 队列元素类
*/
class QueueItem{
    constructor(element,priority){
        this.element = element;
        this.priority = priority;
    }
}

/**
 * 优先级队列封装
 *
 * @class PriorityQueue
 */
class PriorityQueue{
    constructor(){
        this.items = []
    }
    enqueue(element,priority){
        const queueItem = new QueueItem(element,priority);
        if(this.items.length===0){
            this.items.push(queueItem);
            return;
        }
        let added = false
        for(let i=0,j=this.items.length;i<j;i++){
            if(priority<this.items[i].priority){
                this.items.splice(i,0,queueItem);
                added = true;
                break;
            }
        }
        if(!added){
            this.items.push(queueItem);
        }

    }
    dequeue(){
        return this.items.shift();
    }
    clearQueue(){
        this.items = [];
    }
    size(){
        return this.items.length;
    }
    front(){
        return this.items[0];
    }
    isEmpty(){
        return this.items.length === 0;
    }
}

export default PriorityQueue
```
### 链表

问题：

1. 链表优缺点？
2. 链表结构是什么样的？

#### 单向链表

1. 接口说明

   | 接口                       | 说明               |
   | -------------------------- | ------------------ |
   | `insert(position,element)` | 在指定位置插入元素 |
   | `get(position)`            | 获取指定位置的元素 |
   | `set(position, element)` | 设置指定位置的元素 |
   | `remove(element)`          | 删除指定元素 |
   | `removeAt(position)`       | 删除指定位置的元素 |
   | `indexOf(element)`         | 返回元素在链表中的索引位置 |
   | `size()`                   | 返回链表的长度 |
   | `isEmpty()`                | 判断链表是否为空 |
   | `clear()`                  | 清空链表 |
   | `toString()`               | 链表数据转化为字符串 |
   | `contains(element)`        | 判断链表是否包含`element`元素 |
   |   `concat(linkedList)`       | 合并两个链表 |
   | `addFirst(element)`          | *向链表头添加新元素* |
   |  ``                          |                    |
   | ``                           |                    |
   |  ``                          |                    |
   |  ``                          |                    |
   |  ``                          |                    |

   

   

